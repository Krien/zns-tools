#include <linux/nvme.h>
#include <linux/blkdev.h>
#include <linux/blk-mq.h>

// TODO: set this with the parent script
/* NOTE, the values are defined as 512B sector size
 * Change the below define to 12 for 4K sector size
 */

#define SECTOR_SHIFT 9

BEGIN {
    if($# != 2) {
         printf("Invalid args. Requires [dev name] [Zone Size].");
         exit();
    }

    @ZONE_MASK = ~($2 - 1);
    @logging = 0; // Set logging to 1 for debugging
}

k:nvme_setup_cmd / ((struct request *)arg1)->q->disk->disk_name == str($1) / {
    $nvme_cmd = (struct nvme_command *)*(arg1+sizeof(struct request));
    $cmd = (((struct request *)arg1)->cmd_flags & REQ_OP_MASK);
    $opcode = (uint8)$nvme_cmd->rw.opcode;
    $cmdid = ((struct request *)arg1)->tag;
    $time = nsecs;

    $secnum = ((struct request *)arg1)->__sector;
    if (!$secnum) {
        // If not passed in struct request get it from nvme request
        $secnum = $nvme_cmd->rw.slba;
    }

    // Bitwise And to get zone starting LBA with zone MASK
    $zlbas = ($secnum & @ZONE_MASK);

    // Trace Write and Append command counters and I/O sizes
    if($cmd == REQ_OP_WRITE || $cmd == REQ_OP_ZONE_APPEND) {
        // Convert data_len to 512B sectors
        $data_len = (((struct request *)arg1)->__data_len >> SECTOR_SHIFT);
        
        @z_nvme_setup_cmd_trackmap[$cmdid] = ($time, pid, tid, $cmd, $zlbas / $2, $secnum, $data_len);
    }

    // Trace Read command counter and total I/O sizes
    if($cmd == REQ_OP_READ) {

        // Convert data_len to 512B sectors
        $data_len = (((struct request *)arg1)->__data_len >> SECTOR_SHIFT);
        @z_nvme_setup_cmd_trackmap[$cmdid] = ($time, pid, tid, $cmd, $zlbas / $2, $secnum, $data_len);
    }

    // If nvme device is in passthrough (e.g., qemu passthrough) Zone reset has flag REQ_OP_DRV_OUT
    // therefore include more checks on nvme_zone_mgnt_action
    if($cmd == REQ_OP_ZONE_RESET || (($cmd == REQ_OP_DRV_OUT && $opcode == nvme_cmd_zone_mgmt_send) && $nvme_cmd->zms.zsa == NVME_ZONE_RESET)) {
        $secnum = $nvme_cmd->rw.slba;
        $zlbas = ($secnum & @ZONE_MASK);

        if(@logging == 1 && $cmd == REQ_OP_DRV_OUT) {
            printf("reset_cmd (passthrough mode) <LBA, ZONE>: <%ld, %d>\n", $secnum, $zlbas / $2);
        }

        if(@logging == 1 && $cmd != REQ_OP_DRV_OUT) {
            printf("reset_cmd <LBA, ZONE>: <%ld, %d>\n", $secnum, $zlbas / $2);
        }

        @z_reset_ctr_map[$zlbas]++;
        @reset_z_track_map[$cmdid] = $zlbas;
        @reset_lat_track_map[$cmdid] = nsecs;
    }

    // reset all zones
    if($cmd == REQ_OP_ZONE_RESET_ALL) {
        @reset_all_ctr++;

        if(@logging == 1) {
            printf("reset_all_cmd\n");
        }
    }
}

k:nvme_complete_rq / ((struct request *)arg0)->q->disk->disk_name == str($1) / {
    $nvme_cmd = (struct nvme_command *)*(arg0+sizeof(struct request));
    $opcode = (uint8)$nvme_cmd->rw.opcode;
    $cmd = (((struct request *)arg0)->cmd_flags & REQ_OP_MASK);
    $cmdid = ((struct request *)arg0)->tag;
    $time = nsecs;

    if($cmd == REQ_OP_WRITE || $cmd == REQ_OP_ZONE_APPEND || $cmd == REQ_OP_READ) {
        $starttime = @z_nvme_setup_cmd_trackmap[$cmdid].0;
        $p = @z_nvme_setup_cmd_trackmap[$cmdid].1;
        $t = @z_nvme_setup_cmd_trackmap[$cmdid].2;
        $c = @z_nvme_setup_cmd_trackmap[$cmdid].3;
        $zlbas_in = @z_nvme_setup_cmd_trackmap[$cmdid].4;
        $secnum_in = @z_nvme_setup_cmd_trackmap[$cmdid].5;
        $data_len_in = @z_nvme_setup_cmd_trackmap[$cmdid].6;
        @z_nvme_rq[$starttime, $p, $t] = ($c, $zlbas_in / $2, $secnum_in, $data_len_in, $time);
    }

    if($cmd == REQ_OP_ZONE_RESET || (($cmd == REQ_OP_DRV_OUT && $opcode == nvme_cmd_zone_mgmt_send) && $nvme_cmd->zms.zsa == NVME_ZONE_RESET)) {
        $zlbas = @reset_z_track_map[$cmdid];
        @z_reset_lat_map[$zlbas, @z_reset_ctr_map[$zlbas]] = nsecs - @reset_lat_track_map[$cmdid];

        // If nvme device is in passthrough (e.g., qemu passthrough) Zone reset has flag REQ_OP_DRV_OUT
        if(@logging == 1 && $cmd == REQ_OP_DRV_OUT) {
            printf("completed reset_cmd (passthrough mode) zone %ld in (usec): %d\n", $zlbas / $2, @z_reset_lat_map[$zlbas, @z_reset_ctr_map[$zlbas]] / 1000);
        }

        if(@logging == 1 && $cmd != REQ_OP_DRV_OUT) {
            printf("completed reset_cmd zone %ld in (usec): %d\n", $zlbas / $2, @z_reset_lat_map[$zlbas, @z_reset_ctr_map[$zlbas]] / 1000);
        }
    }
}

interval:s:5
{
    exit();
}

END {
    clear(@ZONE_MASK);
    clear(@logging);
    clear(@reset_z_track_map);
    clear(@reset_lat_track_map);
    clear(@z_nvme_setup_cmd_trackmap);
}
