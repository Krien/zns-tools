#include <linux/nvme.h>
#include <linux/blkdev.h>
#include <linux/blk-mq.h>

BEGIN {
    if($# != 2) {
         printf("Invalid args. Requires [dev name] [Zone Size].");
         exit();
    }

    @ZONE_MASK = ~($2 - 1);
    @logging = 0; // Set logging to 1 for debugging
}

k:nvme_setup_cmd / ((struct request *)arg1)->q->disk->disk_name == str($1) / {
    $nvme_cmd = (struct nvme_command *)*(arg1+sizeof(struct request));
    $opcode = (uint8)$nvme_cmd->rw.opcode;

    $secnum = $nvme_cmd->rw.slba;
    // Bitwise And to get zone starting LBA with zone MASK
    $zlbas = ($secnum & @ZONE_MASK);

    // Trace Write and Append command counters and I/O sizes
    if($opcode == nvme_cmd_write || $opcode == nvme_cmd_zone_append) {
        // Store zone operation counter map under ZLBAS, operation 0x01 for write and append
        @z_rw_ctr_map[$zlbas, nvme_cmd_write]++;

        // Convert data_len to 512B sectors
        $data_len = (((struct request *)arg1)->__data_len >> 9);
        @z_data_map[$zlbas, nvme_cmd_write] = @z_data_map[$zlbas, nvme_cmd_write] + $data_len; 

        if(@logging == 1) {
            printf("w_cmd at ZLBAS: %ld size: %d\n", $zlbas, $data_len);
        }
    }

    // Trace Read command counter and total I/O sizes
    if($opcode == nvme_cmd_read) {
        // Store zone operation counter map under ZLBAS, operation 0x01 for write and append
        @z_rw_ctr_map[$zlbas, nvme_cmd_read]++;

        // Convert data_len to 512B sectors
        $data_len = (((struct request *)arg1)->__data_len >> 9);
        @z_data_map[$zlbas, nvme_cmd_read] = @z_data_map[$zlbas, nvme_cmd_read] + $data_len; 

        if(@logging == 1) {
            printf("r_cmd at ZLBAS: %ld size: %d\n", $zlbas, $data_len);
        }
    }

    // Trace ZONE RESETS
    $cmd = (((struct request *)arg1)->cmd_flags & REQ_OP_MASK);

    // If nvme device is in passthrough (e.g., qemu passthrough) Zone reset has flag REQ_OP_DRV_OUT
    // therefore include more checks on nvme_zone_mgnt_action
    if($cmd == REQ_OP_ZONE_RESET || (($cmd == REQ_OP_DRV_OUT && $opcode == nvme_cmd_zone_mgmt_send) && $nvme_cmd->zms.zsa == NVME_ZONE_RESET)) {
        if(@logging == 1 && $cmd == REQ_OP_DRV_OUT) {
            printf("reset_cmd (passthrough mode) zlbas: %ld\n", $zlbas);
        }

        if(@logging == 1 && $cmd != REQ_OP_DRV_OUT) {
            printf("reset_cmd zlbas: %ld\n", $zlbas);
        }

        @z_reset_ctr_map[$zlbas]++;
        $cmdid = ((struct request *)arg1)->tag;
        @reset_z_track_map[$cmdid] = $zlbas;
        @reset_lat_track_map[$cmdid] = nsecs;
    }

    // reset all zones
    if($cmd == REQ_OP_ZONE_RESET_ALL) {
        @reset_all_ctr++;

        if(@logging == 1) {
            printf("reset_all_cmd\n");
        }
    }
}

k:nvme_complete_rq / ((struct request *)arg0)->q->disk->disk_name == str($1) / {
    $nvme_cmd = (struct nvme_command *)*(arg0+sizeof(struct request));
    $opcode = (uint8)$nvme_cmd->rw.opcode;
    $cmd = (((struct request *)arg0)->cmd_flags & REQ_OP_MASK);

    if($cmd == REQ_OP_ZONE_RESET || (($cmd == REQ_OP_DRV_OUT && $opcode == nvme_cmd_zone_mgmt_send) && $nvme_cmd->zms.zsa == NVME_ZONE_RESET)) {
        $cmdid = ((struct request *)arg0)->tag;
        $zlbas = @reset_z_track_map[$cmdid];
        @z_reset_lat_map[$zlbas, @z_reset_ctr_map[$zlbas]] = nsecs - @reset_lat_track_map[$cmdid];

        // If nvme device is in passthrough (e.g., qemu passthrough) Zone reset has flag REQ_OP_DRV_OUT
        if(@logging == 1 && $cmd == REQ_OP_DRV_OUT) {
            printf("completed reset_cmd (passthrough mode) zlbas %ld in: %d\n", $zlbas, @z_reset_lat_map[$zlbas, @z_reset_ctr_map[$zlbas]]);
        }

        if(@logging == 1 && $cmd != REQ_OP_DRV_OUT) {
            printf("completed reset_cmd zlbas %ld in: %d\n", $zlbas, @z_reset_lat_map[$zlbas, @z_reset_ctr_map[$zlbas]]);
        }
    }
}

END {
    clear(@ZONE_MASK);
    clear(@logging);
    clear(@reset_z_track_map);
    clear(@reset_lat_track_map);
}
