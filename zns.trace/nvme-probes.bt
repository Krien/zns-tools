#include <linux/nvme.h>
#include <linux/blkdev.h>
#include <linux/blk-mq.h>

// TODO: make this apply to zns and non zns, so zone mask may be 0
/* NOTE, the values are defined as 512B sector size
 * Change the below define to 12 for 4K sector size
 */

#define SECTOR_SHIFT 9

BEGIN {
    if($# != 2) {
         printf("Invalid args. Requires [dev name] [Zone Size].");
         exit();
    }

    @ZONE_MASK = ~($2 - 1);
}

k:nvme_setup_cmd / ((struct request *)arg1)->q->disk->disk_name == str($1) / {
    $nvme_cmd = (struct nvme_command *)*(arg1+sizeof(struct request));
    $cmd = (((struct request *)arg1)->cmd_flags & REQ_OP_MASK);
    $opcode = (uint8)$nvme_cmd->rw.opcode;
    $cmdid = ((struct request *)arg1)->tag;
    $time = nsecs;

    $secnum = ((struct request *)arg1)->__sector;
    if (!$secnum) {
        // If not passed in struct request get it from nvme request
        $secnum = $nvme_cmd->rw.slba;
    }

    // Bitwise And to get zone starting LBA with zone MASK
    $zlbas = ($secnum & @ZONE_MASK);

    // Trace Write and Append command counters and I/O sizes
    if($cmd == REQ_OP_WRITE || $cmd == REQ_OP_ZONE_APPEND || $cmd == REQ_OP_READ) {
        // Convert data_len to 512B sectors
        $data_len = (((struct request *)arg1)->__data_len >> SECTOR_SHIFT);
        
        @nvme_setup_cmd_trackmap[$cmdid] = ($time, pid, tid, $cmd, $zlbas / $2, $secnum, $data_len);
    }

    // If nvme device is in passthrough (e.g., qemu passthrough) Zone reset has flag REQ_OP_DRV_OUT
    // therefore include more checks on nvme_zone_mgnt_action
    if($cmd == REQ_OP_ZONE_RESET || (($cmd == REQ_OP_DRV_OUT && $opcode == nvme_cmd_zone_mgmt_send) && $nvme_cmd->zms.zsa == NVME_ZONE_RESET)) {
        $secnum = $nvme_cmd->rw.slba;
        $zlbas = ($secnum & @ZONE_MASK);

        @nvme_rq_reset_trackmap[$cmdid] = ($time, pid, tid, $cmd, $zlbas / $2, $secnum)
    }
}

k:nvme_complete_rq / ((struct request *)arg0)->q->disk->disk_name == str($1) / {
    $nvme_cmd = (struct nvme_command *)*(arg0+sizeof(struct request));
    $opcode = (uint8)$nvme_cmd->rw.opcode;
    $cmd = (((struct request *)arg0)->cmd_flags & REQ_OP_MASK);
    $cmdid = ((struct request *)arg0)->tag;
    $time = nsecs;

    if($cmd == REQ_OP_WRITE || $cmd == REQ_OP_ZONE_APPEND || $cmd == REQ_OP_READ) {
        $starttime = @nvme_setup_cmd_trackmap[$cmdid].0;

        /* if bpf map runs out of memory the corresponding setup trace event is dropped and we have to drop the completion event */
        if ($starttime != 0) {
            $p = @nvme_setup_cmd_trackmap[$cmdid].1;
            $t = @nvme_setup_cmd_trackmap[$cmdid].2;
            $c = @nvme_setup_cmd_trackmap[$cmdid].3;
            $zlbas_in = @nvme_setup_cmd_trackmap[$cmdid].4;
            $secnum_in = @nvme_setup_cmd_trackmap[$cmdid].5;
            $data_len_in = @nvme_setup_cmd_trackmap[$cmdid].6;
            @nvme_rq[$starttime, $p, $t] = ($c, $zlbas_in, $secnum_in, $data_len_in, $time);
        }
    }

    if($cmd == REQ_OP_ZONE_RESET || (($cmd == REQ_OP_DRV_OUT && $opcode == nvme_cmd_zone_mgmt_send) && $nvme_cmd->zms.zsa == NVME_ZONE_RESET)) {
        $starttime = @nvme_rq_reset_trackmap[$cmdid].0;

        /* if bpf map runs out of memory the corresponding setup trace event is dropped and we have to drop the completion event */
        if ($starttime != 0) {
            $p = @nvme_rq_reset_trackmap[$cmdid].1;
            $t = @nvme_rq_reset_trackmap[$cmdid].2;
            $c = @nvme_rq_reset_trackmap[$cmdid].3;
            $zlbas_in = @nvme_rq_reset_trackmap[$cmdid].4;
            $secnum_in = @nvme_rq_reset_trackmap[$cmdid].5;
            @nvme_reset[$starttime, $p, $t] = ($c, $zlbas_in, $secnum_in, $time);
        }
    }
}

interval:s:5
{
    exit();
}

END {
    clear(@ZONE_MASK);
    clear(@nvme_rq_reset_trackmap);
    clear(@nvme_setup_cmd_trackmap);
}
